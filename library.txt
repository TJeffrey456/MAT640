# this is where to add the new functions 
read `AGT.txt`:
read `support.txt`:

# things to add find Hamilton if Dirac holds, Eulerian (check degrees), Chinese postman problem, perfect matching, coloring (Brooke's thm), find chromatic polynomial
# Check if we can do anything fun with planarity
# We should do smth with Max flow - min cut (Ford Fulkerson, Edmon-Karp)
Helpnew:=proc():
    print(`The ADDITIONAL procedures (added by Jeffrey Tang and Matthew Esaia) are: DiracThm(G), isHamiltonian(G), isEulerian(G), ChromaticPolynomial(G), FordFulkerson(G,s,t), PerfectMatching(G), ColorGraph(G)`):
end:
Helpnew():
print(`To access the list of newly added main procedures again, type "Helpnew()"`):


# Given a graph G = [n,E], returns true if Dirac's Theorem holds true and false otherwise
DiracThm:=proc(G) local n,E,L,i,mindeg:
    n := G[1]:
    E := G[1]:
    L := Degrees(G):

    mindeg := infinity:

    for i from 1 to n do
        if (L[i] < mindeg) then
            mindeg := L[i]:
        fi:
    od:

    if mindeg >= n/2 then
        RETURN(true):
    else
        RETURN(false):
    fi:
end:

# isHamiltonian(G), determines if a Graph is Hamiltonian, find a Hamiltonian path if Dirac's Thm holds 
isHamiltonian:=proc(G) local DiracHolds, neighbors_list, i, minDegree, vertices, startNode, path:
    DiracHolds := DiracThm(G):
    if DiracHolds then
        # find the path this will be exponential - NP Hard
        neighbors_list := Neis(graph);

        minDegree := infinity;
        for i from 1 to n do
            minDegree := min(minDegree, nops(neighbors_list[i]));
        od:

        vertices := convert({seq(i, i=1..n)}, list);

        # Try starting the search from each vertex
        for startNode in vertices do
            path := FindPath([startNode], convert(vertices minus {startNode}, set));
            if path <> FAIL then
                return path;
            fi:
        od:
    else
        RETURN(FAIL, "Dirac's Theorem does not hold!")
    fi:
end:

# isEulerian(G) determines if a graph is Eulerian, return Eulerian circuit if true
isEulerian:= proc(G) local degList, VisitedE, CCset, trail, stack, neighbors, nextV, i, e, curr:
    n = G[1]:
    E = G[2]:
    degList := Degrees(G):
    for i in n do
        if degList[i] mod 2 <> 0 then 
            RETURN(FAIL, "G has a vertex of odd degree!")
        fi:
    od:
    # so its Eulerian, find the circuit

    # Step 2: Check that the graph is connected
    CCset := CC([n, E], 1):
    if {seq(i, i=1..n)} minus CCset <> {} then
        RETURN(FAIL, "Graph is not connected"):
    fi:
    
    # Hierholzer's algorithm for Eulerian path (simpler than Fleuryâ€™s)
    VisitedE := {}:
    trail := []:
    stack := [1]:  # Start from vertex 1 (arbitrary, since it's Eulerian)
    neighbors := table():
    
    for i from 1 to n do
        neighbors[i] := {}:
    od:
    for e in E do
        neighbors[e[1]] := neighbors[e[1]] union {[e[1], e[2]]}:
        neighbors[e[2]] := neighbors[e[2]] union {[e[2], e[1]]}:
    od:
    
    while nops(stack) > 0 do
        curr := stack[-1]:
        if neighbors[curr] = {} then
            trail := [op(trail), curr]:
            stack := stack[1..-2]:
        else
            nextV := op(1, neighbors[curr]):
            neighbors[curr] := neighbors[curr] minus {nextV}:
            neighbors[nextV[2]] := neighbors[nextV[2]] minus {[nextV[2], nextV[1]]}:
            stack := [op(stack), nextV[2]]:
        fi:
    od:
    
    trail:
end:


# Finding the chromatic polynomial of a graph using Deletion-contraction algorithm
ChromaticPolynomial := proc(G) local n, E, edge, G_minus_e, G_contracted_e, v1, v2, remaining_vertices, contracted_vertices, new_edges, neighbor, i, curr_e;
option remember; # this is for Memoization
    n := G[1];
    E := G[2];

    # Base Cases
    # Empty
    if E = {} then
        return k^n;
    fi:
    # NULL
    if n = 0 then
        return 1; 
    fi:

    # Choose an edge (since we know its not empty, choose the first one)
    edge := E[1];
    v1 := edge[1];
    v2 := edge[2];

    # Delete
    G_minus_e := [n, E minus {edge}];

    # contracted
    remaining_vertices := {seq(i, i=1..n)} minus {v1, v2};
    contracted_vertices := [v1_v2]; # Represent the merged vertex
    new_edges := {};

    # Add edges from remaining vertices to the contracted vertex
    for neighbor in Neis(G)[v1] union Neis(G)[v2] do
        if neighbor in remaining_vertices then
            new_edges := new_edges union {{v1_v2, neighbor}};
        fi:
    od:

    # Add edges between the remaining vertices (that were not incident to e)
    for curr_e in E minus {edge} do
        if curr_e[1] in remaining_vertices and curr_e[2] in remaining_vertices then
            new_edges := new_edges union {curr_e};
        fi:
    od:

    G_contracted_e := [n - 1, new_edges]:

    return ChromaticPolynomial(G_minus_e) - ChromaticPolynomial(subs(v1_v2 = k, G_contracted_e));
end:


# Finds the max flow from s to t given a weighted adjacency matrix G
FordFulkerson:=proc(G, s, t) local u,v,residual_G,n,parent,max_flow,path_flow,i,j:
    n := nops(G):
    residual_G := [seq([seq(0, j=1..n)], i=1..n)]:

    for u from 1 to n do
        for v from 1 to n do
            residual_G[u][v] := G[u][v]:
        od:
    od:

    parent := BFS(residual_G,s,t):
    max_flow := 0:

    while parent <> false do
        printf(max_flow):
        path_flow := infinity:

        v := t:
        while v <> s do
            u = parent[v];
            path_flow = min(path_flow, residual_G[u][v]);
            v := parent[v];
        od:

        v := t:
        while v <> s do
            u = parent[v];
            residual_G[u][v] -= path_flow;
            residual_G[v][u] += path_flow;

            v := parent[v]:
        od:

        max_flow += path_flow:

        parent := BFS(residual_G,s,t):
    od:

    RETURN(max_flow):
end:

# Perfect Matching: Given a graph, it will return a perfect matching
PerfectMatching := proc(G)  local matched, match, used, u, v, i, e:
  n = G[1]:
  E = G[2]:
  
  matched := {}:
  used := Array(1..n, fill = false):
  for e in E do
    u=e[1]:
    v=e[2]:
    if not used[u] and not used[v] then
      matched := matched union {[u, v]}:
      used[u] := true; 
      used[v] := true:
    fi:
  od:
  
  matched:
end:

# Finding the chromatic number of a graph using Brooke's Thm as an upper limit, returns the color
# assignment and the total number of colors used
ColorGraph := proc(G) local color, e, i, neighbors, u, c, usedColors, maxColor, n, E:
  n = G[1]:
  E = G[2]:
  color := Array(1..n, fill = 0):
  maxColor := 0:

  for i from 1 to n do
    neighbors := {}:
    # get the neighbors of vertex i
    for e in E do
      if e[1] = i then
          neighbors := neighbors union {e[2]}:
      elif e[2] = i then
          neighbors := neighbors union {e[1]}:
      fi:
    od:

    usedColors := {}:
    for u in neighbors do
      if color[u] <> 0 then
          usedColors := usedColors union {color[u]}:
      fi:
    od:

    c := 1;
    while member(c, usedColors) do
      c := c + 1:
    od:

    color[v] := c;
    if c > maxColor then
        maxColor := c;
    fi:
  od:

  [color, maxColor]:
end: