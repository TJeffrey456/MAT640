# this is where to add support functions


Helpsupport:=proc()
    print(`These are the SUPPORTING procedures we added after instruction: DegreeList(G), BFS(G,s,t)`):
end:
Helpsupport():
print(`To access the list of newly added support procedures again, type "Helpsupport()"`):

# Given a graph G = [n,E], returns the list of degrees for each vertex
DegreeList := proc(G) local n,E,e,L:
    n := G[1]:
    E := G[2]:

    L := [seq(0, 1..n)]:

    # Iterates over the edges and increments the corresponding degrees
    for e in E do
        L[e[1]] := L[e[1]] + 1:
        L[e[2]] := L[e[2]] + 1:
    od:

    RETURN(L):
end:

# Given a graph G = weighted adjacency matrix and vertices s and t, runs BFS on G starting from s
# Returns parent[] to store the if there is a path from s to t
# Otherwise, returns false
BFS:=proc(G,s,t) local n,visited,queue,parent,u,v:
    n := nops(G):

    visited := [seq(0$n)]:
    parent := [seq(0$n)]:

    queue := {s}:
    visited[s] := 1:
    parent[s] := -1:

    while queue <> {} do
        u := queue[1]:
        queue := queue minus {u}:

        for v from 1 to n do
            if (visited[v] = 0 and G[u][v] > 0) then
                if (v = t) then
                    parent[v] := u:
                    RETURN(parent):
                fi:

                queue := queue union {v}:
                parent[v] := u:
                visited[v] := 1:
            fi:
        od:
    od:

    RETURN(false):
end:

# Backtracking function to find a Hamiltonian path
FindPath := proc(currentPath, remainingNodes) local currentNode, current_neighbors, neighbor, newRemaining, newPath, result;
    if nops(currentPath) = n then
        return currentPath; # Hamiltonian path found
    fi:

    currentNode := currentPath[-1]:
    current_neighbors := neighbors_list[currentNode];

    for neighbor in current_neighbors do
        if neighbor in remainingNodes then
            newRemaining := remainingNodes minus {neighbor};
            newPath := [op(currentPath), neighbor];
            result := FindPath(newPath, newRemaining);
            if result <> FAIL then
                return true, result;
            fi:
        fi:
    od:
    return FAIL:
end: