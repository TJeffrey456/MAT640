# this is where to add support functions


# add BFS, DFS, 
print(`These are the SUPPORTING procedures we added after instruction: Degrees(G), BFS(G,u)`):


# Given a graph G = [n,E], returns the list of degrees for each vertex
Degrees:=proc(G) local n,E,e,L:
    n := G[1]:
    E := G[2]:

    L := [seq(0, 1..n)]:

    # Iterates over the edges and increments the corresponding degrees
    for e in E do
        L[e[1]] := L[e[1]] + 1:
        L[e[2]] := L[e[2]] + 1:
    od:

    RETURN(L):
end:

# Given a graph G = [n,E] and a vertex u, runs BFS on G starting from u
# Returns ...
BFS:=proc(G,u) local visited:
    
end:

# Backtracking function to find a Hamiltonian path
FindPath := proc(currentPath, remainingNodes) local currentNode, current_neighbors, neighbor, newRemaining, newPath, result;
    if nops(currentPath) = n then
        return currentPath; # Hamiltonian path found
    fi:

    currentNode := currentPath[-1]:
    current_neighbors := neighbors_list[currentNode];

    for neighbor in current_neighbors do
        if neighbor in remainingNodes then
            newRemaining := remainingNodes minus {neighbor};
            newPath := [op(currentPath), neighbor];
            result := FindPath(newPath, newRemaining);
            if result <> FAIL then
                return true, result;
            fi:
        fi:
    od:
    return FAIL:
end: